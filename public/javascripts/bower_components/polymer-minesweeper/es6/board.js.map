{"version":3,"sources":["src/board.js"],"names":[],"mappings":"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","file":"src/board.js","sourcesContent":["'use strict';\nPolymer({\n  created() {\n    this.gameOver = false;\n    this.win = false;\n    this.doneExploding = false;\n    this.flagCount = 0;\n    this.grid = null; // Grid object\n  },\n  /**\n   * IMPORTANT: Attributes configured via an element e.g. <x-foo name=\"bar\"></x-foo>\n   * are not available in the `created`lifecycle method. They first become available\n   * in the `ready` lifecycle method.\n   */\n  ready() {\n    this.grid = new MSPolymer.Grid(this.rows, this.columns, this.mines);\n  },\n  computed: {\n    'gameEndMessage': 'win ? \"YOU WIN\" : \"GAME OVER\"'\n  },\n  flaggedHandler(Event, object, element) {\n    this.flagCount += object; // object is 1 or -1\n    this.checkWin();\n  },\n  checkWin() {\n    this.win = this.grid.hasWon();\n    if (this.win) {\n      this.gameOver = true;\n    }\n  },\n  /**\n   * Recursively self reveals cells as 0 risk cells are revealed.\n   * Recursion is oddly handled through animation. See `propagate` on ms-cell.html.\n   */\n  revealNeighbors(Event, object, element) {\n    let position = element.id.split('_').slice(-2); // get grid position from id\n    let row = parseInt(position[0]);\n    let col = parseInt(position[1]);\n    let revealNeighbor = this.grid.forEachSurroudingCell(row, col);\n    revealNeighbor((r, c) => {\n      /**\n       * Common Polymer gotcha:\n       * Automatic node finding only works 1 level deep in the shadow DOM tree.\n       * Anything deeper can be accessed by using `querySelector` on an\n       * automatically found node.\n       */\n      let neighbor = this.$.board.querySelector('#cid_' + r + '_' + c);\n      if (!neighbor.cell.flagged) {\n        neighbor.revealed = true; // recursion via data-binding\n      }\n    }, this);\n  },\n  /**\n   * As soon as any mine explodes, this method fires off the rest\n   * to make it a board-wide explosion.\n   */\n  createExplosion(Event, object, element) {\n    this.gameOver = true;\n\n    let mineCellIds = this.grid.mineArray.map((id) => '#' + id).join(',');\n    let minesArr = Array.from(this.$.board.querySelectorAll(mineCellIds));\n    minesArr = shuffleArray(minesArr); // shuffle the mines for a random explosion effect\n\n    // know when to show the game over message - after we're done exploding\n    let explodedCount = 0;\n    let explode = (e) => {\n      if (e.animationName === 'explode') {\n        explodedCount++;\n        if (explodedCount === this.mines - this.flagCount) {\n          this.doneExploding = true\n        }\n      }\n    };\n    this.addEventListener('webkitAnimationEnd', explode);\n    this.addEventListener('MSAnimationEnd', explode);\n    this.addEventListener('animationend', explode);\n\n    minesArr.forEach((cell, i) => {\n      setTimeout(() => {\n        if (!cell.cell.flagged) {\n          cell.revealed = true; // explode unflagged mines\n        }\n      }, i % 2 === 0 ? i * 15 : i * 12);\n    });\n  }\n});\n\n/*\nUtils\n */\nfunction shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n}\n"]}