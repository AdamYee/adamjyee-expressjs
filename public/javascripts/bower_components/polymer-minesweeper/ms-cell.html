<link rel="import" href="../polymer/polymer.html">

<polymer-element
  name="ms-cell"
  attributes="cell revealed"
  on-click="{{reveal}}"
  on-contextmenu="{{flag}}"
  horizontal center-justified layout center>
  <template>
    <style>
    :host {
      background-color: #ccc;
      border: 1px solid #191919;
      width: 30px;
      height: 30px;
      position: relative;
      font-family: monospace;
      font-weight: bold;
    }
    :host(.revealed) {
      background-color: #eee;
      -webkit-animation: ripple 75ms, fade 300ms;
      animation: ripple 75ms, fade 300ms;
    }
    .flagged {
      z-index: 99;
      background: #000;
      width: 12px;
      text-align: center;
      position: absolute;
      top: 7px;
      left: 9px;
    }
    .drop-flag {
      -webkit-animation: flag 150ms;
      animation: flag 150ms;
    }
    .pickup-flag {
      -webkit-animation: flag 250ms reverse;
      animation: flag 250ms reverse;
    }
    :host(.explode) {
      background-color: #eee;
      -webkit-animation: ripple 275ms, explode 275ms;
      animation: ripple 275ms, explode 275ms;
    }
    @-webkit-keyframes flag {
      0% {
        opacity: 0;
        top: -100px;
        left: -15px;
        width: 30px;
        height: 30px;
      }
      30% {
        opacity: 0.6;
      }
      100% {
        opacity: 1;
        top: 10px;
        left: 10px;
        width: 10px;
        height: 15px;
      }
    }
    @-webkit-keyframes ripple {
      0% {
        z-index: 99;
        width: 30px;
        height: 30px;
        margin: 0;
      }
      70% {
        width: 38px;
        height: 38px;
        /**
         * shrinking the margin in sync with height and width growth
         * prevents the height and width from pushing everything around it.
         */
        margin: -4px;
      }
      100% {
        z-index: 0;
        width: 30px;
        height: 30px;
        margin: 0;
      }
    }
    @-webkit-keyframes fade {
      0% { background-color: #ccc; }
      100% { background-color: #eee; }
    }
    @-webkit-keyframes explode {
      50% {
        background-color: orangered;
        box-shadow: 0 0 65px 10px red;
      }
    }
    
    @keyframes flag { 0% { opacity: 0; top: -100px; left: -15px; width: 30px; height: } 30% { opacity: 0.6; } 100% { opacity: 1; top: 10px; left: 10px; width: 10px; height: 15px; } }
    @keyframes ripple { 0% { z-index: 99; width: 30px; height: 30px; margin: 0; } 70% { width: 38px; height: 38px; margin: -4px; } 100% { z-index: 0; width: 30px; height: 30px; margin: 0; } }
    @keyframes fade { 0% { background-color: #ccc; } 100% { background-color: #eee; } }
    @keyframes explode { 50% { background-color: orangered; box-shadow: 0 0 65px 10px red; } }
    
    </style>
    <div id="content" hidden?="{{hide}}" style="color: {{color}}">{{displayVal}}</div>
  </template>
  <script>
    'use strict';
    Polymer('ms-cell', {
      publish: {
        cell: null,
        revealed: {
          value: false,
          reflect: true
        }
      },
      computedDisplayVal: function(flagged, revealed) {
        if(flagged && !revealed) {
          return 'F';
        } else {
          return this.cell.revealedVal();
        }
      },
      computed: {
        'hide'            : '!cell.flagged && !revealed',
        'displayVal'      : 'computedDisplayVal(cell.flagged, revealed)'
      },
      ready: function() {
        this.color = this.cell.color();
        /**
         * Recursively reveal a 0 risk cell's neighbors.
         * And check for wins if revealing a risky cell.
         */
        var propagate = function() {
          // only need to fire reveal-neighbors once
          if(this.revealed && !this.cell.mine) {
            this.removeEventListener('webkitAnimationEnd', propagate);
            this.removeEventListener('MSAnimationEnd', propagate);
            this.removeEventListener('animationend', propagate);
            if(this.cell.risk === 0) {
              this.fire('reveal-neighbors');
            } else {
              this.fire('check-win');
            }
          }
        }.bind(this);
        this.addEventListener('webkitAnimationEnd', propagate);
        this.addEventListener('MSAnimationEnd', propagate);
        this.addEventListener('animationend', propagate);
      },
      revealedChanged: function() {
        if(this.revealed) {
          this.cell.revealed = true;
          this.setAttribute('class', this.cell.mine ? 'explode' : 'revealed');
        }
      },
      reveal: function(event, detail, sender) {
        // do nothing if it's already revealed or if it's been flagged.
        if(this.revealed || this.cell.flagged) {
          return;
        }
        this.revealed = true;
        if(this.cell.mine) {
          this.fire('explosion');
        }
      },
      /**
       * Event handler for context menu clicks (flagging mines)
       */
      flag: function (e) {
        e.preventDefault();
        if(this.revealed) {
          return;
        } else {
          if(!this.cell.flagged) {
            this.$.content.setAttribute('class', 'flagged drop-flag');
            this.cell.flagged = true;
            this.color = 'orange';
            this.fire('flagged', 1);
          } else {
            var removeFlag = function() {
              this.cell.flagged = false;
              this.color = this.cell.color();
              this.fire('flagged', -1);
              this.$.content.setAttribute('class', '');
              this.removeEventListener('webkitAnimationEnd', removeFlag);
              this.removeEventListener('MSAnimationEnd', removeFlag);
              this.removeEventListener('animationend', removeFlag);
            };
            this.addEventListener('webkitAnimationEnd', removeFlag);
            this.addEventListener('MSAnimationEnd', removeFlag);
            this.addEventListener('animationend', removeFlag);
            /**
             * Animate the flag pickup:
             * Removing a class with animation (possible specific to reverse animation)
             * and then adding a class with animation on different cycles (eventloops)
             * seems to do the trick.
             */
            var content = this.$.content;
            content.setAttribute('class', 'flagged');
            setTimeout(function () {
              content.setAttribute('class', 'flagged pickup-flag');
            }, 0);
          }
        }
      }
    });
  </script>
</polymer-element>
